package com.fileupload.service;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.LinkedBlockingQueue;

import com.fileupload.downloaders.FtpDownloader;
import com.fileupload.downloaders.HttpDownloader;
import com.fileupload.downloaders.IGenericDownloader;
import com.fileupload.downloaders.SftpDownloader;
import com.fileupload.model.FileMetadata;

public class DownloadThreads implements Runnable {

	LinkedBlockingQueue<FileMetadata> downloadQueue;

	public DownloadThreads(LinkedBlockingQueue<FileMetadata> downloadQueue) {
		this.downloadQueue = downloadQueue;
	}
/*
 * (non-Javadoc)
 * @see java.lang.Runnable#run()
 * This thread runs till downloadQueue is not empty. 
 * 
 * A thread will poll an url from queue. Try downloading it. 
 * 
 * If it fails it is pushed again in downloadQueue after incrementing the retryCount.
 * The failed file will be picked again after all remaining files are tried once. (FIFO)
 * Hence a corrupt url will not block other downloads.In every retry corrupted file is deleted.
 * 
 * A file is retried for maximum 3 times.
 * 
 */
	public void run() {
		while (!downloadQueue.isEmpty()) {
			IGenericDownloader downloader = null;
			FileMetadata fileMetadata = downloadQueue.poll();
			if(fileMetadata!=null){
				String uniqueFileSavePath = generateUniqueName(fileMetadata.getUrl(), fileMetadata.getDownloadLocation());
				if (uniqueFileSavePath!=null && fileMetadata.getRetryCount() < 3) {
					boolean result = false;
					switch (fileMetadata.getProtocol()) {
					case http:
						downloader = HttpDownloader.getInstance();
						break;
					case ftp:
						downloader = FtpDownloader.getInstance();
						break;
					case sftp:
						downloader = SftpDownloader.getInstance();
						break;
					default:
						downloader=null;
					break;
					}
					if(downloader!=null){
						result = downloader.downloadFile(fileMetadata.getUrl(), uniqueFileSavePath);
					}
					if (!result) {
						fileMetadata.incrementRetryCount();
						try {
							System.out.println("Failed for url: "+fileMetadata.getUrl()+", Will retry again with retryCount: "+fileMetadata.getRetryCount());
							removeUncompleteFile(uniqueFileSavePath);
							downloadQueue.put(fileMetadata);
						} catch (InterruptedException e) {
							System.out.println("Failed for url: " + fileMetadata.getUrl());
						}
					} else {
						System.out.println("Successfully downloaded: "+fileMetadata.getUrl()+":url to path: "+uniqueFileSavePath);
					}
				} else {
					removeUncompleteFile(uniqueFileSavePath);
					System.out.println("Retry Limit exceeded for url: " + fileMetadata.getUrl());
				}
			}
		}
	}

/*
 * This function accept a web url and directory where file will be saved.
 * 
 * fileName is extracted from url and checked if it exists in the given directory. 
 * 
 * New fileNames are generated by appending number starting from 1.
 * If a new fileName is found. A temporary file is created by that name. Unique name is returned.
 * 
 */
	private String generateUniqueName(String url, String saveDir) {
		int fileNameIndex = url.lastIndexOf("/") + 1;
		String fileName = url.substring(fileNameIndex);
		String fullFileName = saveDir+File.separator+fileName;
		
		int count =0;
		String fileNameWithoutExtension;
		String extension;
		
		int extensionIndex = fileName.lastIndexOf(".");
		if(extensionIndex!=-1){
			fileNameWithoutExtension = saveDir+File.separator+fileName.substring(0,extensionIndex);
			extension = fileName.substring(extensionIndex);
		}
		else{
			fileNameWithoutExtension = saveDir+File.separator+fileName;
			extension="";
		}
		
		File f = new File(fullFileName);
		
/*
 * It is synchronized because two threads can have same file Name. 
 * i.e example: 
 * Thread1: http://speedtest.ftp.otenet.gr/files/test100k.db
 * Thread2: http://tempFiles.com/files/test100k.db
 * 
 * Both threads will try to generate the name for file test100k.db.
 * Hence lock is taken on a common object. i.e downloadQueue
 * 
 */
		synchronized (downloadQueue) {
			try {
				while(f.exists()){
					count++;
					fullFileName = fileNameWithoutExtension+count+extension;
					f = new File(fullFileName);
				}
				f.createNewFile();
			} catch (IOException e) {
				e.printStackTrace();
				return null;
			}
			return fullFileName;
		}
	}

	private void removeUncompleteFile(String fullPath) {
		if(fullPath!=null){
			File f = new File(fullPath);
			f.delete();
		}
	}

}
